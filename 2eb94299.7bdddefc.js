(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{230:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return d}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),p=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=p(n),b=a,d=u["".concat(s,".").concat(b)]||u[b]||h[b]||o;return n?r.a.createElement(d,i(i({ref:t},l),{},{components:n})):r.a.createElement(d,i({ref:t},l))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=b;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},94:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return p}));var a=n(3),r=n(7),o=(n(0),n(230)),s={title:"Super Type Tokens"},i={permalink:"/dddtdd-docs/blog/2021/02/18/super-type-tokens",source:"@site/blog\\2021-02-18-super-type-tokens.md",description:"\u8f6c\u81ea\uff1a",date:"2021-02-18T00:00:00.000Z",tags:[],title:"Super Type Tokens",readingTime:4.565,truncated:!1,nextItem:{title:"\u5207\u6362\u5230docusaurus",permalink:"/dddtdd-docs/blog/2020/12/03/switch-to-docusaurus"}},c=[],l={rightToc:c};function p(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"\u8f6c\u81ea\uff1a",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"http://gafter.blogspot.com/2006/12/super-type-tokens.html"}),"http://gafter.blogspot.com/2006/12/super-type-tokens.html")),Object(o.b)("p",null,"When we added generics to Java in JDK5, I changed the class java.lang.Class to become a generic type. For example, the type of String.class is now ",Object(o.b)("inlineCode",{parentName:"p"},"Class<String>"),". Gilad Bracha coined the term type tokens for this. My intent was to enable a particular style of API, which Joshua Bloch calls the THC, or Typesafe Heterogenous Container pattern. For some examples of where this is used see the APIs for annotations:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"public <A extends Annotation> A java.lang.Class.getAnnotation(Class<A> annotationClass)\n")),Object(o.b)("p",null,"My earliest use of this feature (like my earliest use of all recent Java language features) appears in the compiler for the Java programming language (javac), in this case as a utility called Context, and you can find the code in the open source version. It was a utility that allowed the compiler to be written as a bunch of separate classes that all refer to each other, and solved the hard problem of getting all the parts created in an order such that they can be initialized with references to each other. The utility is also used to replace pieces of the compiler, for example to make related tools like javadoc and apt, the Annotation Processing Tool, and for testing. Today I would describe the utility as a simple dependency injection framework, but that wasn't a popular buzzword at the time."),Object(o.b)("p",null,"Here is a simple but complete example of an API that uses type tokens in the THC pattern, from Josh's 2006 JavaOne talk:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'public class Favorites {\n    private Map<Class<?>, Object> favorites =\n        new HashMap<Class<?>, Object>();\n    public <T> void setFavorite(Class<T> klass, T thing) {\n        favorites.put(klass, thing);\n    }\n    public <T> T getFavorite(Class<T> klass) {\n        return klass.cast(favorites.get(klass));\n    }\n    public static void main(String[] args) {\n        Favorites f = new Favorites();\n        f.setFavorite(String.class, "Java");\n        f.setFavorite(Integer.class, 0xcafebabe);\n        String s = f.getFavorite(String.class);\n        int i = f.getFavorite(Integer.class);\n    }\n}\n')),Object(o.b)("p",null,"A Favorites object acts as a typesafe map from type tokens to instances of the type. The main program in this snippet adds a favorite String and a favorite Integer, which are later taken out. The interesting thing about this pattern is that a single Favorites object can be used to hold things of many (i.e. heterogenous) types but in a typesafe way, in contrast to the usual kind of map in which the values are all of the same static type (i.e. homogenous). When you get your favorite String, it is of type String and you don't have to cast it."),Object(o.b)("p",null,"There is a limitation to this pattern. Erasure rears its ugly head:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"Favorites:15: illegal start of expression\nf.setFavorite(List<String>.class, Collections.emptyList());\n                          ^\n")),Object(o.b)("p",null,"You can't add your favorite ",Object(o.b)("inlineCode",{parentName:"p"},"List<String>")," to a Favorites because you simply can't make a type token for a generic type. This design limitation is one that a number of people have been running into lately, most recently Ted Neward. \"Crazy\" Bob Lee also asked me how to solve a related problem in a dependency injection framework he is developing. The short answer is that you can't do it using type tokens."),Object(o.b)("p",null,"On Friday I realized you can solve these problems without using type tokens at all, using a library. I wish I had realized this three years ago; perhaps there was no need to put support for type tokens directly in the language. I call the new idea super type tokens. In its simplest form it looks like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"public abstract class TypeReference<T> {}\n")),Object(o.b)("p",null,"The abstract qualifier is intentional. It forces clients to subclass this in order to create a new instance of TypeReference. You make a super type token for ",Object(o.b)("inlineCode",{parentName:"p"},"List<String>")," like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),"TypeReference<List<String>> x = new TypeReference<List<String>>() {};\n")),Object(o.b)("p",null,"Not quite as convenient as writing ",Object(o.b)("inlineCode",{parentName:"p"},"List<String>.class"),", but this isn't too bad. It turns out that you can use a super type token to do nearly everything you can do with a type token, and more. The object that is created on the right-hand-side is an anonymous class, and using reflection you can get its interface type, including generic type parameters. Josh calls this pattern \"Gafter's Gadget\". Bob Lee elaborated on this idea as follows:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-java"}),'import java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * References a generic type.\n *\n * @author crazybob@google.com (Bob Lee)\n */\npublic abstract class TypeReference<T> {\n\n    private final Type type;\n    private volatile Constructor<?> constructor;\n\n    protected TypeReference() {\n        Type superclass = getClass().getGenericSuperclass();\n        if (superclass instanceof Class) {\n            throw new RuntimeException("Missing type parameter.");\n        }\n        this.type = ((ParameterizedType) superclass).getActualTypeArguments()[0];\n    }\n\n    /**\n     * Instantiates a new instance of {@code T} using the default, no-arg\n     * constructor.\n     */\n    @SuppressWarnings("unchecked")\n    public T newInstance()\n            throws NoSuchMethodException, IllegalAccessException,\n                   InvocationTargetException, InstantiationException {\n        if (constructor == null) {\n            Class<?> rawType = type instanceof Class<?>\n                ? (Class<?>) type\n                : (Class<?>) ((ParameterizedType) type).getRawType();\n            constructor = rawType.getConstructor();\n        }\n        return (T) constructor.newInstance();\n    }\n\n    /**\n     * Gets the referenced type.\n     */\n    public Type getType() {\n        return this.type;\n    }\n\n    public static void main(String[] args) throws Exception {\n        List<String> l1 = new TypeReference<ArrayList<String>>() {}.newInstance();\n        List l2 = new TypeReference<ArrayList>() {}.newInstance();\n    }\n}\n')),Object(o.b)("p",null,"This pattern can be used to solve Ted Neward's problem, and most problems where you would otherwise use type tokens but you need to support generic types as well as reifiable types. Although this isn't much more than a generic factory interface, the automatic hook into the rich generic reflection system is more than you can get with simple class literals. With a few more bells and whistles (toString, hashCode, equals, etc) I think this is a worthy candidate for inclusion in the JDK."))}p.isMDXComponent=!0}}]);